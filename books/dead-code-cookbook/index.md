---
title: "目次"
---



# レシピリスト(目次)

1. `🧪return後のコード`
1. `🧪throw後のコード`
1. `🧪break後のコード`
1. `🧪continue後のコード`
1. `🧪exit後のコード`
1. `🧪常にthrowする関数呼出後のコード`
1. `🧪returnしない関数呼出後のコード`

⇒関数呼び出しについてはifとの重ね合わせがある

1. `🧪条件が常にfalse(リテラル)のif(単一)`
1. `🧪条件が常にfalse(定数)のif(単一)`
1. `🧪条件が常にfalse(変数)のif(単一)`
1. `🧪条件が常にfalse(演算結果)のif(単一)`

付録. 演算結果が固定値を返却するパターン
⇒組み込みか、そうでないか。かつ、解析でどこまでいけるか。
正規表現、

1. `🧪部分集合条件のelseif`
1. `🧪部分集合条件のcase(switch)`

1. `🧪空集合条件のelse`
1. `🧪空集合条件のdefalt(switch)`

1. `🧪部分集合条件のif(ネスト)`

付録. 部分集合条件、空集合条件

1. `🧪空集合条件のfor継続条件`
1. `🧪空集合条件のwhile継続条件`

1. `🧪空集合要素のイテレータ処理`
1. セーフナビゲーターオペレーター

付録. 空集合要素を作る演算

1. ジェネレータのイールド後
(1回しか呼ばれないジェネレータの後処理)

コールバック？？


1. 呼び出されない関数
1. 呼び出されないプライベートメソッド


1. 関数の上書き
1. メソッドとオーバーライド
1. メソッドチェーンの利用
1. 整数値に対する演算の使用 範囲
1. 整数値に対する演算の使用 2じょう
1. 文字列の活用
1. マクロの利用
1. 組み込み例外の利用
1. ソースコードの取得とevalの利用
1. catchの利用
1. gotoの利用
1. never型の利用？
1. ワンライナーの利用"goto fail bug"
1. 三項演算子
1. プロミス？
1. exit。大域脱出？
1. 実行時エラー？の後


void hoge(double a) {
    if (a != a) {

    }
}
↑NaN

void (Double.isInfinited(d1) && Double.isinfinite(d2) && d1 != d2)
↑プラスマイナス無限大

コンストラクタ、ですトラクタ

実行時エラー


正規表現でデッドコードを作る


あとがき。
デッドコードを作れないプログラミング言語
