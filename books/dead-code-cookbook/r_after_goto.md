---
title: "🧪goto後のコード"
---

|||
|:--|:--|
|🔖|[`中断を利用するパターン`](./p_after)|
|👼|[`中断コード削除`](./a_after_stop_delete) [`ネスト修正による中断コードの移動`](./a_after_stop_move)|
|🧟|[`goto文のラベルによるジャンプ`](./z_goto) [`ホイスティング`](./z_hoisting)|

`goto` は、指定したラベルにジャンプする。

ラベルを利用する点で、ラベル付きの `break` と共通点があるが、ラベル付の `break` を利用したデッドコードレシピは本書では [`🧪break後のコード`](./r_after_break) に含めるものとする。

`goto` は自由度が高すぎ、可読性を損なう書き方ができることにより、使われる機会は少ないでしょう。そのため、 `goto` を採用している言語は限られます。

なお、本書の [`🔖中断を利用するパターン`](./p_after) は、 **中断された処理以降に記載されているコードを、デッドコード** としているため、 `goto` 後にラベルを記載しているケースは [`🧟goto文のラベルによるジャンプ`](./z_goto) として考える。`goto` を用いると自然と本書のゾンビ化のパターンを利用してしまうことがある。このことは、 `goto` 自由度が高すぎ、可読性を損なう書き方ができるということの一例といえるだろう。

 - デバッグのために残した `goto` が残ってしまった。 -> [`👼中断コード削除`](./a_after_stop_delete)
 - `if` 文等の条件内を想定していたが、ネストを誤った。 -> [`👼ネスト修正による中断コードの移動`](./a_after_stop_move)
 - マージ等で `goto` 文が重複した。 -> [`👼中断コード削除`](./a_after_stop_delete)
 - `goto` 追加による修正後、不要なコードを消さなかった。 -> `🛐供養`
 - 削除対象にgoto文のラベルが記載されている。 -> [`🧟goto文のラベルによるジャンプ`](./z_goto)
 - 削除対象にホイスティング対象が記載されている。  -> [`🧟ホイスティング`](./z_hoisting)


# 言語毎

|言語|実行可否|ツール|検知可否|
|:--|:--|:--|:--|
|Python|対象外|-|-|
|Ruby|対象外|-|-|
|JavaScript|対象外|-|-|
|Java|対象外|-|-|
|Go|実行可|-|-|

## Python

対象外

## Ruby

対象外

## JavaScript

対象外

## Java

対象外

## Go

``` go:after_goto.go:./projects/golang/src/after_goto.go
package main

import "fmt"

func main() {
	goto L
	fmt.Println("Am I dead?")
L:
	return
}

```

``` console
$ # コード実行
$ go run src/after_goto.go
$ 
```
