---
title: "🔖中断を利用するパターン"
---

# 説明

構造化プログラミングは、原則として、順次、つまり上から下に実行される。

`🔖中断を利用するパターン` は、中断、すなわち、それ以降処理が実行されない記載を利用する。 **中断された処理以降に記載されているコードは、デッドコードとなる** 。

中断させるためには、 **`return` などの予約語** を用いることができる。予約語のみではなく、 **組み込み関数の `exit`** や、 **中断させる関数を定義して使用** することもできる。また、大抵のプログラミング言語には実行時エラーがあり、 **実行時エラー** は処理が中断するだろう。

最もシンプルなパターンであり、特に予約後を用いたパターンはデッドコードであることが分かりやすい。
特に、予約後を用いたパターンは分かりやすい。実際のコードでは

本パターンの多くで使用できるレイズは、 [`👼中断コード削除`](./a_after_stop_delete) と [`👼ネスト修正による中断コードの移動`](./a_after_stop_move) である。

また、多くで使用できるゾンビ化は、 [`🧟goto文のラベルによるジャンプ`](./z_goto) と [`🧟ホイスティング`](./z_hoisting) である。

# レシピ一覧

1. [`🧪return後のコード`](./r_after_return)
1. [`🧪throw後のコード`](./r_after_throw)
1. [`🧪break(loop)後のコード`](./r_after_loop_break)
1. [`🧪continue(loop)後のコード`](./r_after_loop_continue)
1. [`🧪break(switch)後のコード`](./r_after_switch_break)
1. [`🧪goto後のコード`](./r_after_goto)
1. [`🧪exit後のコード`](./r_after_exit)
1. [`🧪常にthrowする関数呼出後のコード`](./r_after_func_throw)
1. [`🧪常にbreakする高階関数呼出後のコード`](./r_after_break_yield)
1. [`🧪常に実行時エラーとなる処理後のコード`](./r_after_runtime_error)
