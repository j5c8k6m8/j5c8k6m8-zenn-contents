---
title: "はじめに"
---

# 本書の目的

デッドコードは、 **プログラムの一部として存在するが、決して実行されないコード** のことである。一時的な変更等でデッドコードを作る場合もあるが、多くの場合は **バグ（プログラム自体の誤り）の可能性が極めて高い** だろう。例えば 「**goto fail bug**[^1]」 がデッドコードを含んだ有名なバグの実例だ。

[^1]: https://ja.wikipedia.org/wiki/%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E3%82%B3%E3%83%BC%E3%83%89#%E8%84%86%E5%BC%B1%E6%80%A7%E3%81%A8%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E6%80%A7

そのため、理想的にはプログラミング言語レベルでデッドコードを検知し、警告出力や実行不可などの対応をとることが望ましい。実際に、特定のパターンのデッドコードは言語仕様上許されていない場合もある。

しかし、任意のコードが到達不能(デッドコード)かどうかを判断することは停止性問題を解くことと等価であり、 **あらゆるデッドコードを正しく把握することは不可能**[^2] である。デッドコードを完全に排除している汎用プログラミング言語は、今のところ存在していないだろう。

[^2]: https://ja.wikipedia.org/wiki/%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E3%82%B3%E3%83%BC%E3%83%89#%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E6%80%A7%E3%81%AE%E6%A4%9C%E8%A8%BC

**では、実際のプログラミングのコードには、どのようなデッドコードのパターンがあるのだろうか？**

この疑問の答えを求めるのが本書である。

しかしながら、デッドコードは除去すべきものであり、デザインパターンのように、再利用を促すものではない。では、 **デッドコードのパターンから何が得られるのだろうか？**

デッドコードのパターンを整理するためには、プログラミングのパターンを整理する必要がある。それは、単なるデッドコードを回避するという直接的な理由以外に、 **プログラミングのパターンやスタイルについての考察を深める** ことにも繋がる。

また、デッドコードが実行可能かどうかは、プログラミング言語によっても異なる。また、あるプログラミング言語ではデッドコードとなるパターンであっても、高度な機能や特殊な記載を用いることで、別のプログラミング言語ではコードを通すことが出来る場合もある。そのため、デッドコードのパターンを整理し、プログラミング言語毎の具体例を確認することで、 **各プログラミング言語への理解を深める** ことにも繋がる。

あるいは、実際のプロジェクトで、前任者が書いたデッドコードに出くわした経験がある人も多いだろう。デッドコードの除去はソースの可読性を向上させ、保守のしやすさにつながる。しかし、デッドコードの除去で動作が変わらない（影響がない）と言えるだろうか？リスク回避という観点からデッドコードの除去を断念することもあるだろう。もし、該当のデッドコードに関する考察がすでになされていて、注意点がまとまっていればどうだろうか？ **正確なデッドコードの除去を後押しする** ことができるだろう。

これらが、本書の目的である。

つまり、 **デッドコードのパターンを通して** 、プログラミングのパターンやスタイルについての考察を深め、各プログラム言語への理解を深め、正確なデッドコードの除去を後押しし、 **より良いコードを書く** ことである。

本書のタイトルは「**DEAD CODE COOKBOOK**」、デッドコードのレシピ集である。

しかし、本書は **意図的にデッドコードを作るためのレシピ集ではない。**

見つけ難い不具合を意図的に埋め込むためではなく、 **より良いコードを書く** ためにのみ活用してほしい。


# 対象範囲と用語の定義


## ☠️デッドコード☠️

**デッドコード(dead coad)** は一般的に到達不能なコードを表わす言葉である。類語の **到達不能コード(unreachable code)** との使い分けは行わず、本書ではデッドコードで統一する。

本書のデッドコードは、以下の２点を対象外として扱う。

 - 実行時のコード(機械語、あるいは元のプログラムよりも低い水準のコード)
 - コメント、アノテーション、変数への代入など、処理を伴わないコード

上記により、 **大半のオプティマイザで削除されるであろう、未参照変数に対する代入は対象外** とする。未使用関数の定義は、オプティマイザで削除されるとしても、処理を伴うコードのため対象とする。

また、本書のデッドコードは **厳密に到達不能のコードのみではなく、後述するデッドコードレシピに基づいたコードも含む**。


## 🧪デッドコードレシピ🧪

デッドコードの作り方、つまり、デッドコードを実現できる **プログラミング言語の機能の組み合わせを、「デッドコードレシピ」** と定義する。

デッドコードレシピに従ったパターンによるソースコードであれば、デッドコードとする。つまり、厳密には到達可能であっても、 **分別のあるプログラミング[^3]では到達不能と認識されるソースコードはデッドコード** とする。たとえば、プロトタイプ汚染のみにより到達可能なコードはデッドコードである。

[^3]: "Rubyは君を信頼する。Rubyは君を**分別のあるプログラマ**として扱う。Rubyはメタプログラミングのような強力な力を与える。ただし、大いなる力には大いなる責任が伴うことを忘れてはいけない。"
— 序文 - まつもとゆきひろ “メタプログラミングRuby 第2版”, Paolo Perrotta.


## 🛐供養🛐

デッドコードの **該当部分のみを削除することを「供養」** と定義する。

通常、デッドコードは存在しないほうが望ましい。デッドコードを削除するにあたり、挙動を変えない場合は該当部分のみを削除、つまり供養すればよい。

ただし、 **供養してはいけないケースがある** 点には注意が必要だ。供養する場合は、次の２点を気にする必要が有るだろう。

１つめは、そのデッドコードに関わる処理に、 **バグが存在しないかの確認** だ。そもそも、バグによりデッドコードになっている場合に供養すると、挙動は変わらないが、バグが残る。バグを残さないためには、後述のレイズによりデッドコードが実行されるように修正する必要がある。

２つめは、一見到達不能に見えるが、 **厳密には到達可能ではないかの確認** だ。一見到達不能に見えるが、厳密には到達可能なデッドコードの場合は、供養により挙動が変わってしまう。後述のゾンビ化によりソースコードが実行されていないかを確認する必要がある。

このことから、供養については **方法は簡単だが、判断が難しい** といえる。供養には、時として勇気が必要となる。

本書では、 **供養の方法は明確(該当部分の削除)なため逐一記載しない** 。しかし、後述する復活の呪文はなるべく詳細に記載する。それは、復活の呪文の知識が、供養の判断の後押しをするためである。

**供養を躊躇ってもよいが、怠ってはいけない。大半のデッドコードは供養するのが正解である。**


## 🧙復活の呪文🧙

デッドコードの処理を **実行するための方法を「復活の呪文」** と定義する。

復活の呪文は、２種類に分けることができる。

１つめは、 **該当箇所のソースコードの書き換えを伴う** もので、これを「レイズ」として後述する。

２つめは、 **該当箇所のソースコードの書き換えを伴わない** もので、これを「ゾンビ化」として後述する。

なお、復活させずにソースコードから削除する方法は、前述の供養である。供養は復活の呪文ではない。


## 👼レイズ👼

**ソースコードを書き換えて、デッドコードを到達可能にすることを「レイズ」** と定義する。

レイズは、デッドコードを作り込んだ理由を想定し、ソースコードを正しい状態にする。**プログラムの挙動が変わる** ため、レイズの正しさは、個別のコード毎に判断して慎重に実施する必要がある。

レイズされたデッドコードは、 **デッドコードレシピから外れるため、デッドコードではなくなる** 。

**レイズが必要なデッドコードは、レイズすべき** である。しかし、意図して到達不能にしたデッドコードに対しては、レイズを行ってはいけない。

本書は、誤って供養しないためにレイズについての記載を行う。しかし、 **多くの場合は供養が正解であり、レイズが正解ではない点** には注意してほしい。


## 🧟ゾンビ化🧟

**該当箇所のソースコードを書き換えずに、デッドコードを実行にすることを「ゾンビ化」** と定義する。

厳密には到達可能なデッドコードについては、分別のあるプログラミングでは実行することが出来ない。つまり、高度な機能や特殊な記載を用いる必要がある。本書では、 **各プログラミング言語の理解を深めること** と、 **ゾンビ化によってデッドコードが有効になっていないことの確認** のために、ゾンビ化の記載を行う。

**ゾンビ化によって有効になっているデッドコードは特殊であり、対処も難しい** だろう。本書では、これらに対する対処は対象外として記載しない。

ほとんどの場合、 **ゾンビ化によって有効になっているデッドコードは可読性を落とし、保守性を著しく低下させる点** には注意してほしい。


## 🐕ケルベロス🐕

**前提条件担保のため、意図的に設けられたデッドコードを「ケルベロス」** と定義する。

デッドコードは、基本的に可読性の観点から望ましくない。到達不能なデッドコードに、あたかも意味があるような処理が記載されていた場合、コードの解読に必要以上に（もっといえば、無意味に）時間がかかってしまうだろう。しかし、 **到達不能なデッドコードに、到達不能を想定している記載がある場合** はどうだろうか？ガード節(Guard Clause) のように **可読性を向上させる場合もある** だろう。（ケルベロスは冥界の番犬 ≒ デッドコードの番人である）

実際に、 **「念のため」という言葉が付いたデッドコードを目にした経験** がある人も多いのではないだろうか。

もちろん、厳密に到達不能なデッドコードは、カバレッジ等で扱いが複雑になるため、ケルベロスを推奨するわけではない。しかし、 **たとえばTypeScriptのnever型**[^4] などの機能を考慮すると、プログラミングスタイルやテストツール環境によっては、 **到達不能なデッドコードに、到達不能を想定している記載** をして可読性をあげる選択肢もある。

[^4]: https://typescript-jp.gitbook.io/deep-dive/type-system/never

本書では、 **ケルベロスの是非は議論しない** が、デッドコードレシピが **ケルベロスとして適用できるかは記載** する。

# 本書のデッドコードに対する考え方

 - **☠️デッドコード☠️ は原則として邪悪(evil)であり、取り除くべきである。**
 - **プログラミングスタイルによっては、🐕ケルベロス🐕 は許容される場合がある。**
 - **単純に 🛐供養🛐 するのではなく、🧙復活の呪文🧙 を考慮する。**
   - **👼レイズ👼 が必要か？**
   - **🧟ゾンビ化🧟 で有効になってないか？**
 - **🧪デッドコードレシピ🧪 をアンチパターンとすることで、より良いコードを書くことができる。**


# サンプルコードと実行環境

本書では **具体例を示すためのサンプルコードを記載** する。

サンプルコードのデッドコードは、「**Am I dead?**」と標準出力するコードを用いる。

サンプルコードのプログラミング言語は、 **特定の言語に限定せず、複数のプログラミング言語** を使用する。

**バージョンの違いによる挙動の違いまでは考慮せず、執筆時点での最新のバージョン** を用いる。例えば、本書でのpythonは、python3を対象として、python2は対象外とする。

デッドコードへの対応は、プログラム言語の機能のみではなく、静的解析ツールを使う場合も多い。本書では、 **著名な静的解析ツールについては対象** とする。

対象のプログラミング言語のバージョンや静的解析ツールなどの環境については 付録 に記載する。


# 対象読者

本書は、


# 読者へのお願い

筆者はプログラミングの経験が不十分。（特に高度な機能）
パターンも他に有るだろうし、言語のサンプルが充分でないこともある。
プルリクをして欲しい。もしくは、Qiitaでもいいだろう。ハッシュタグで呟いてもいいし、

2020年度のアドベンドカレンダー形式の本とする試み。

これは、時間をかけてじっくり読んでもらう事で、いろんな意見がもらえるのではないか？という意図がある。

全てに目を通すことは難しいかもしれないが、時間をかけて可能な限り本書に反映していくつもりがある。


paiza

## 対象言語と環境

|プログラミング言語|Dockerタグ|
|:--|:--|
|C言語||
|Python||
|JavaScript(Node.js)||
|Ruby|ruby:2.7.2-buster|
|Go|1.15.4-buster|
|Java|openjdk:15.0.1|
|TypeScript||
|Rust||

環境構築は別章とする。

``` console
docker run --rm -v $ZENN_HOME/books/dead-code-cookbook/src/ruby:/app/ruby ruby:2.7.2-buster ruby /app/ruby/hello_world.rb && echo success
```

``` console
docker run --rm -v $ZENN_HOME/books/dead-code-cookbook/src/golang:/app/golang golang:1.15.4-buster go run /app/golang/hello_world.go && echo success
```


# レシピ(目次)

1. リテラルを利用した条件式
1. ローカル変数を利用した条件式
1. 定数を利用した条件式
1. return後のコード
1. throw後のコード
1. break/continue後のコード
1. 条件の重ねあわせ。分岐のネスト
1. 条件の重ね合わせ。switch
1. 空配列のeach
1. 正規表現の利用
1. プライベートメソッドの活用
1. 関数の上書き
1. メソッドとオーバーライド
1. メソッドチェーンの利用
1. 整数値に対する演算の使用 範囲
1. 整数値に対する演算の使用 2じょう
1. 文字列の活用
1. マクロの利用
1. 組み込み例外の利用
1. ソースコードの取得とevalの利用
1. catchの利用
1. gotoの利用
1. never型の利用？
1. ワンライナーの利用"goto fail bug"
1. 三項演算子
1. プロミス？
1. exit。大域脱出？


void hoge(double a) {
    if (a != a) {

    }
}
↑NaN

void (Double.isInfinited(d1) && Double.isinfinite(d2) && d1 != d2)
↑プラスマイナス無限大
