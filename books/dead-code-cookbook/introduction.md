---
title: "はじめに"
---

# 本書の目的

デッドコードは、 **プログラムの一部として存在するが、決して実行されないコード** のことである。一時的な変更等でデッドコードを作る場合もあるが、多くの場合は **バグ（プログラム自体の誤り）の可能性が極めて高い** だろう。例えば 「**goto fail bug**[^1]」 がデッドコードを含んだ有名なバグの実例だ。

[^1]: https://ja.wikipedia.org/wiki/%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E3%82%B3%E3%83%BC%E3%83%89#%E8%84%86%E5%BC%B1%E6%80%A7%E3%81%A8%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E6%80%A7

そのため、理想的にはプログラミング言語レベルでデッドコードを検知し、警告出力や実行不可などの対応をとることが望ましい。実際に、特定のパターンのデッドコードは言語仕様上許されていない場合もある。

しかし、任意のコードが到達不能(デッドコード)かどうかを判断することは停止性問題を解くことと等価であり、 **あらゆるデッドコードを正しく把握することは不可能**[^2] である。デッドコードを完全に排除している汎用プログラミング言語は、今のところ存在していないだろう。

[^2]: https://ja.wikipedia.org/wiki/%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E3%82%B3%E3%83%BC%E3%83%89#%E5%88%B0%E9%81%94%E4%B8%8D%E8%83%BD%E6%80%A7%E3%81%AE%E6%A4%9C%E8%A8%BC

**では、実際のプログラミングのコードには、どのようなデッドコードのパターンがあるのだろうか？**

この疑問の答えを求めるのが本書である。

しかしながら、デッドコードは除去すべきものであり、デザインパターンのように、再利用を促すものではない。では、 **デッドコードのパターンから何が得られるのだろうか？**

デッドコードのパターンを整理するためには、プログラミングのパターンを整理する必要がある。それは、単なるデッドコードを回避するという直接的な理由以外に、 **プログラミングのパターンやスタイルについての考察を深める** ことにも繋がる。

また、デッドコードが実行可能かどうかは、プログラミング言語によっても異なる。また、あるプログラミング言語ではデッドコードとなるパターンであっても、高度な機能や特殊な記載を用いることで、別のプログラミング言語ではコードを通すことが出来る場合もある。そのため、デッドコードのパターンを整理し、プログラミング言語毎の具体例を確認することで、 **各プログラミング言語への理解を深める** ことにも繋がる。

あるいは、実際のプロジェクトで、前任者が書いたデッドコードに出くわした経験がある人も多いだろう。デッドコードの除去はソースの可読性を向上させ、保守のしやすさにつながる。しかし、デッドコードの除去で動作が変わらない（影響がない）と言えるだろうか？リスク回避という観点からデッドコードの除去を断念することもあるだろう。もし、該当のデッドコードに関する考察がすでになされていて、注意点がまとまっていればどうだろうか？ **正確なデッドコードの除去を後押しする** ことができるだろう。

これらが、本書の目的である。

つまり、 **デッドコードのパターンを通して** 、プログラミングのパターンやスタイルについての考察を深め、各プログラム言語への理解を深め、正確なデッドコードの除去を後押しし、 **より良いコードを書く** ことである。

本書のタイトルは「**DEAD CODE COOKBOOK**」、デッドコードのレシピ集である。

しかし、本書は **意図的にデッドコードを作るためのレシピ集ではない。**

見つけ難い不具合を意図的に埋め込むためではなく、 **より良いコードを書く** ためにのみ活用してほしい。


# 対象範囲と用語の定義


## ☠️デッドコード☠️

**デッドコード(dead coad)** は一般的に到達不能なコードを表わす言葉である。類語の **到達不能コード(unreachable code)** との使い分けは行わず、本書ではデッドコードで統一する。

本書のデッドコードは、以下の２点を対象外として扱う。

 - 実行時のコード(機械語、あるいは元のプログラムよりも低い水準のコード)
 - 実行結果から、処理の有無を確認できないコード

上記により、 **大半のオプティマイザで削除されるであろう、未参照変数に対する代入や、未使用のシグネチャ定義は対象外** とする。なお、未使用の関数定義や、余分なコールバック引数は、処理されていないことが確認できるため、対象とする。

また、本書のデッドコードは **厳密に到達不能のコードのみではなく、後述するデッドコードレシピに基づいたコードも含む**。


## 🧪デッドコードレシピ🧪

デッドコードの作り方、つまり、デッドコードを実現できる **プログラミング言語の機能の組み合わせを、「デッドコードレシピ」** と定義する。

デッドコードレシピに従ったパターンによるソースコードであれば、デッドコードとする。つまり、厳密には到達可能であっても、 **分別のあるプログラミング[^3]では到達不能と認識されるソースコードはデッドコード** とする。たとえば、プロトタイプ汚染のみにより到達可能なコードはデッドコードである。

[^3]: "Rubyは君を信頼する。Rubyは君を**分別のあるプログラマ**として扱う。Rubyはメタプログラミングのような強力な力を与える。ただし、大いなる力には大いなる責任が伴うことを忘れてはいけない。"
— 序文 - まつもとゆきひろ “メタプログラミングRuby 第2版”, Paolo Perrotta.

本書では、デッドコードレシピについて、 **複数のプログラミング言語でサンプルコードを記載** する。


## 🔖デッドコードパターン🔖

デッドコードレシピは、プログラミング言語の機能単位をベースとするため、細かい定義となる。そのため、本書では **デッドコードレシピを、「デッドコードパターン」で分類** して記載する。


## 🔪デッドコードツール🔪

デッドコードレシピでは、使用されるプログラミング言語の機能を一般化して一部の例を記載する場合もある。そのため、デッドコードを作るうえで、 **役立つ考え方や、共通して使えるプログラミングの部品を「デッドコードツール」として詳細化** して記載する。デッドコードツールとしてトピックを分けることで、デッドコードレシピをわかり易く記載し、かつ、プログラミング言語の広範な機能を本書の対象とすることができる。


## 🛐供養🛐

デッドコードの修正時に **該当部分のみを削除することを「供養」** と定義する。

通常、デッドコードは存在しないほうが望ましい。デッドコードを削除するにあたり、挙動を変えない場合は該当部分のみを削除、つまり供養すればよい。

ただし、 **供養してはいけないケースがある** 点には注意が必要だ。供養する場合は、次の２点を気にする必要が有るだろう。

１つめは、そのデッドコードに関わる処理に、 **バグが存在しないかの確認** だ。そもそも、バグによりデッドコードになっている場合に供養すると、挙動は変わらないが、バグが残る。バグを残さないためには、後述のレイズによりデッドコードが実行されるように修正する必要がある。

２つめは、一見到達不能に見えるが、 **厳密には到達可能ではないかの確認** だ。一見到達不能に見えるが、厳密には到達可能なデッドコードの場合は、供養により挙動が変わってしまう。後述のゾンビ化によりソースコードが実行されていないかを確認する必要がある。

このことから、供養については **方法は簡単だが、判断が難しい** といえる。供養には、時として勇気が必要となる。

本書では、 **供養の方法は明確(該当部分の削除)なため逐一記載しない** 。しかし、後述する復活の呪文はなるべく詳細に記載する。それは、復活の呪文の知識が、供養の判断の後押しをするためである。

**供養を躊躇ってもよいが、怠ってはいけない。大半のデッドコードは供養するのが正解である。**


## 🧙復活の呪文🧙

デッドコードの処理を **実行するための方法を「復活の呪文」** と定義する。

復活の呪文は、２種類に分けることができる。

１つめは、 **該当箇所のソースコードの書き換えを伴う** もので、これを「レイズ」として後述する。

２つめは、 **該当箇所のソースコードの書き換えを伴わない** もので、これを「ゾンビ化」として後述する。

なお、復活させずにソースコードから削除する方法は、前述の供養である。供養は復活の呪文ではない。


## 👼レイズ👼

**ソースコードを書き換えて、デッドコードを到達可能にすることを「レイズ」** と定義する。

レイズは、デッドコードを作り込んだ理由を想定し、ソースコードを正しい状態にする。**プログラムの挙動が変わる** ため、レイズの正しさは、個別のコード毎に判断して慎重に実施する必要がある。

レイズされたデッドコードは、 **デッドコードレシピから外れるため、デッドコードではなくなる** 。

**レイズが必要なデッドコードは、レイズすべき** である。しかし、意図して到達不能にしたデッドコードに対しては、レイズを行ってはいけない。

本書は、誤って供養しないためにレイズについての記載を行う。しかし、 **多くの場合は供養が正解であり、レイズが正解ではない点** には注意してほしい。


## 🧟ゾンビ化🧟

**該当箇所のソースコードを書き換えずに、デッドコードを実行にすることを「ゾンビ化」** と定義する。

厳密には到達可能なデッドコードについては、分別のあるプログラミングでは実行することが出来ない。つまり、高度な機能や特殊な記載を用いる必要がある。本書では、 **各プログラミング言語の理解を深めること** と、 **ゾンビ化によってデッドコードが有効になっていないことの確認** のために、ゾンビ化の記載を行う。

**ゾンビ化によって有効になっているデッドコードは特殊であり、対処も難しい** だろう。本書では、これらに対する対処は対象外として記載しない。

ほとんどの場合、 **ゾンビ化によって有効になっているデッドコードは可読性を落とし、保守性を著しく低下させる点** には注意してほしい。


## 🐕ケルベロス🐕

**前提条件担保のため、意図的に設けられたデッドコードを「ケルベロス」** と定義する。一般的には、assertion(表明)と呼ばれる概念[^4] が存在するが、より範囲を限定した定義としてケルベロスを用いる。

[^4]: https://ja.m.wikipedia.org/wiki/%E8%A1%A8%E6%98%8E

デッドコードは、基本的に可読性の観点から望ましくない。到達不能なデッドコードに、あたかも意味があるような処理が記載されていた場合、コードの解読に必要以上に（もっといえば、無意味に）時間がかかってしまうだろう。しかし、 **到達不能なデッドコードに、到達不能を想定している記載がある場合** はどうだろうか？ガード節(Guard Clause) のように **可読性を向上させる場合もある** だろう。（ケルベロスは冥界の番犬 ≒ デッドコードの番人である）

実際に、 **「念のため」という言葉が付いたデッドコードを目にした経験** がある人も多いのではないだろうか。

もちろん、厳密に到達不能なデッドコードは、カバレッジ等で扱いが複雑になるため、ケルベロスを推奨するわけではない。しかし、 **たとえばTypeScriptのnever型**[^5] などの機能を考慮すると、プログラミングスタイルやテストツール環境によっては、 **到達不能なデッドコードに、到達不能を想定している記載** をして可読性をあげる選択肢もある。

[^5]: https://typescript-jp.gitbook.io/deep-dive/type-system/never

本書では、 **ケルベロスの是非は議論しない** が、デッドコードレシピが **ケルベロスとして適用できるかは記載** する。


# 本書のデッドコードに対する考え方

 - **☠️デッドコード☠️ は原則として邪悪(evil)であり、取り除くべきである。**
 - **プログラミングスタイルによっては、🐕ケルベロス🐕 は許容される場合がある。**
 - **単純に 🛐供養🛐 するのではなく、🧙復活の呪文🧙 を考慮する。**
   - **👼レイズ👼 が必要か？**
   - **🧟ゾンビ化🧟 で有効になってないか？**
 - **🧪デッドコードレシピ🧪 をアンチパターンとすることで、より良いコードを書くことができる。**


# サンプルコードと実行環境

本書では **具体例を示すためのサンプルコードを記載** する。

サンプルコードのデッドコードは、「**Am I dead?**」と標準出力するコードを用いる。

サンプルコードのプログラミング言語は、 **特定の言語に限定せず、複数のプログラミング言語** を使用する。

デッドコードへの対応は、プログラム言語の機能のみではなく、静的解析ツールを使う場合も多い。本書では、 **著名な静的解析ツールについては対象** とする。

::: message
アドベントカレンダー期間に公開していくことを考え、まずはプログラミング言語 / 静的解析ツールを限定する。 プログラミング言語は、 `Python`, `Ruby`, `JavaScript`, `Java`, `Go` を記載し、将来的には、`TypeScript`, `Rust`, `Scala` あたりから対象言語を増やしていく予定。静的解析ツールは、 `flake8(Python)`, `rubocop(Ruby)`, `eslint(JavaScript)` を記載する。
:::

対象のプログラミング言語のバージョンや静的解析ツールなどの環境については [`🧰対象言語と環境`](./environment) に記載する。


# 対象読者

本書は、 **プログラミング経験者を対象とし、プログラミングの基礎についての説明は行わない** 。しかし、本書は特定のプログラミング言語に限定しないため、 **初心者でも分かる説明** で記載する。**デッドコード自体は中級者以降では作りこむことはほとんどない** だろう。しかし、中級者でも **他のプログラミング言語に関する知識や、ゾンビ化に用いる高度な機能は参考になる** だろう。そのため、 **本書は習熟度によって違った楽しみ方** ができるだろう。

初心者： プログラミングにおける機能の確認。デッドコードという **アンチパターンを通した、プログラミングスタイルの学習** 。

中級者以降： **各プログラミング言語毎の高度な機能の確認** 。プログラミング言語毎の、各種機能のサポート状況等の確認。


# 読者へのお願い

本書は **特定のプログラム言語に特化せずにパターンを紹介** します。プログラミング言語毎にエラーになる、警告になる、記法をサポートしてない、静的解析ツールで検出可能など、状況が異なります。

本書は、実際のデッドコード除去時の参考となることも目的としているため、 **なるべく多くのプログラミング言語でサンプルコードや挙動を掲載したい** と思っています。しかしながら、筆者の経験しているプログラミング言語は数個しかありません。また、高度なプログラミングに対する知識も十分ではありません。

**本書は筆者だけでは目的を達成する本が書けない** と考えています。

- **デッドコードレシピのサンプルコードを書いた**
- **掲載されてないデッドコードレシピがある**
- **掲載されてない復活の呪文がある**
- **誤字脱字含む文章校正**

そのため、 **上記のような協力や、🪓マサカリ🪓も歓迎** しています。
**[本書のGitHub](https://github.com/j5c8k6m8/dead-code-cookbook)のPR(プルリクエスト)** 、 **Zennの本書のスクラップ(Scraps)** 、 **twitterのハッシュタグ([#デッドコードクックブック](https://twitter.com/hashtag/%E3%83%87%E3%83%83%E3%83%89%E3%82%B3%E3%83%BC%E3%83%89%E3%82%AF%E3%83%83%E3%82%AF%E3%83%96%E3%83%83%E3%82%AF), [#デッドコードレシピ](https://twitter.com/hashtag/%E3%83%87%E3%83%83%E3%83%89%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AC%E3%82%B7%E3%83%94))** などでの連絡をお待ちしています。


## アドベントカレンダー形式での公開について

本書は、 **2020年12月１日から、12月25日まで、毎日チャプターを一つずつ公開していく方式** をとっています。

これは、本書を書こうとは思ったものの、完成までの道のりが長いと感じたので、期間を決めてモチベーションを保ちつつ、 **執筆しながら意見がもらいやすいのではないか？** と考えたためです。~~Zennで本を書きたい、[Zennでアドベントカレンダーをしたい](https://zenn.dev/j5c8k6m8/articles/zenn-adcal-github-action)、というのも理由のひとつ~~

当初は、アドベントカレンダーの期間中に完成させようと思っていましたが、一覧を記載してみると、 **アドベントカレンダーの期間中の完成は難しい** と感じました。アドベントカレンダーの期間中の完成は諦め、毎日更新する方針に変更しました。

2020年12月25日以降も更新していくつもりではありますが、2020年12月25日を区切りに、いったん `あとがき` を執筆する予定です。2020年のアドベントカレンダーの期間中に色んな意見をもらえると嬉しく、また、励みになります！


# Contributers

[j5c8k6m8](https://zenn.dev/j5c8k6m8)
